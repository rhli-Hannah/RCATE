if (is.vector(x.tr)) {
x.tr <- matrix(x.tr, ncol = 1)
}
# Estimate mu0(x), mu1(x) and p(x)
data.p <- data.frame(cbind(factor(d), x))
colnames(data.p)[1] <- c("d")
data.p$d <- as.factor(data.p$d)
gbmGrid.p <- expand.grid(interaction.depth = interaction.depth.p,
n.trees = n.trees.p, shrinkage = shrinkage.p,
n.minobsinnode = n.minobsinnode.p)
gbmFit.p <- caret::train(d ~ ., data = data.p, method = "gbm",
verbose = FALSE, trControl = caret::trainControl(method = "cv", number = cv.p),
tuneGrid = gbmGrid.p)
pscore.hat <- caret::predict.train(gbmFit.p, newdata = data.p, type = "prob")[, 2]
data00 <- data.frame(cbind(y, x, d))
colnames(data00)[c(1,ncol(data00))] <- c("y", "d")
# data020 <- data00[data00$d == 0, ]
# data021 <- data00[data00$d == 1, ]
gbmGrid.mu <- expand.grid(interaction.depth = interaction.depth.mu,
n.trees = n.trees.mu, shrinkage = shrinkage.mu,
n.minobsinnode = n.minobsinnode.mu)
gbmFit.mu <- caret::train(y ~ ., data = data00[, -ncol(data00)],
method = "gbm", verbose = FALSE, trControl = caret::trainControl(method = "cv",
number = cv.mu), tuneGrid = gbmGrid.mu, metric = "MAE")
# gbmFit.mu1 <- caret::train(y ~ ., data = data021[, -ncol(data021)],
#                            method = "gbm", verbose = FALSE, trControl = caret::trainControl(method = "cv",
#                            number = cv.mu), tuneGrid = gbmGrid.mu, metric = "MAE")
# gbmFit.mu0 <- caret::train(y ~ ., data = data020[, -ncol(data020)],
#                            method = "gbm", verbose = FALSE, trControl = caret::trainControl(method = "cv",
#                            number = cv.mu), tuneGrid = gbmGrid.mu, metric = "MAE")
#
# mu0 <- caret::predict.train(gbmFit.mu0, newdata = data00)
# mu1 <- caret::predict.train(gbmFit.mu1, newdata = data00)
mu.ea <- caret::predict.train(gbmFit.mu, newdata = data00)
# Do transformation
if (method == "MCMEA") {
w.tr <- 1/(t * pscore.hat + (1 - t)/2)
y.tr <- (y - mu.ea) * w.tr
wmat.tr <- matrix(0, row, row)
diag(wmat.tr) <- w.tr * t/2
Btilde <- B_R(x.num.scaled, x.num.scaled, lambda.smooth, nknots, colnum)
x.tr1 <- wmat.tr %*% as.matrix(cbind(rep(1, row), Btilde, x.other))
} else if (method == "RL") {
w.tr <- 1
y.tr <- (y - mu.ea) * w.tr
wmat.tr <- matrix(0, row, row)
diag(wmat.tr) <- w.tr * (t - 2 * pscore.hat + 1)/2
Btilde <- B_R(x.num.scaled, x.num.scaled, lambda.smooth, nknots, colnum)
x.tr1 <- wmat.tr %*% as.matrix(cbind(rep(1, row), Btilde, x.other))
}
# Fit the weighted LAD model with group SCAD
model <- rqPen::cv.rq.group.pen(x = x.tr1, y = y.tr, groups = as.factor(c(max(group)+1, group)),
tau = 0.5, intercept = FALSE, penalty = 'SCAD',
nfolds = nfolds, criteria = "BIC", nlambda = nlambda)
# Get coefficients and fitted value
coef <- coef(model)
fitted.values <- as.matrix(cbind(rep(1, nrow(Btilde)), Btilde, x.other)) %*% coef
result <- list(model = model, method = method, algorithm = "SAM",
lambda.smooth = lambda.smooth, fitted.values = fitted.values,
x = x, y = y, d = d, y.tr = y.tr, w.tr = w.tr,
coef = coef, colnum = colnum, nknots = nknots,
param = list(x.scaled=x.scaled, name.num=name.num,
x.mean=x.mean, x.sd=x.sd, x.num.scaled = x.num.scaled))
class(result) <- "rcate.am"
return(result)
}
n <- 1000; p <- 2; set.seed(2223)
X <- as.data.frame(matrix(runif(n*p,-3,3),nrow=n,ncol=p))
tau = 3*X[,1]-2*X[,2]
p = 1/(1+exp(-X[,1]+X[,2]))
d = rbinom(n,1,p)
t = 2*d-1
y = 100+tau*t/2 + rnorm(n,0,1); set.seed(2223)
x_val = as.data.frame(matrix(rnorm(200*2,0,1),nrow=200,ncol=2))
tau_val = 3*x_val[,1]-2*x_val[,2]
fit <- rcate.am(X,y,d,lambda.smooth = 4, method = 'RL')
fit$coef
y_pred <- predict.rcate.am(fit,x_val)$pred
plot(tau_val,y_pred);abline(0,1)
marginal.rcate.am(fit,'V1')
marginal.rcate.am(fit,'V2')
object=fit
model <- object$model
algorithm <- object$algorithm
x <- object$x
x.mean <- object$param$x.mean
x.sd <- object$param$x.sd
if (is.null(variable.name)) {
variable.name <- colnames(object$param$x.scaled)[1]
}
x.select <- seq(min(x[,variable.name]),max(x[,variable.name]),length.out = 200)
x.cond.scaled <- (x.select-x.mean[variable.name])/x.sd[variable.name]
x.cond <- data.frame(matrix(0,ncol = ncol(x),nrow = 200))
colnames(x.cond) <- colnames(object$param$x.scaled)
variable.name=NULL
model <- object$model
algorithm <- object$algorithm
x <- object$x
x.mean <- object$param$x.mean
x.sd <- object$param$x.sd
if (is.null(variable.name)) {
variable.name <- colnames(object$param$x.scaled)[1]
}
x.select <- seq(min(x[,variable.name]),max(x[,variable.name]),length.out = 200)
x.cond.scaled <- (x.select-x.mean[variable.name])/x.sd[variable.name]
x.cond <- data.frame(matrix(0,ncol = ncol(x),nrow = 200))
colnames(x.cond) <- colnames(object$param$x.scaled)
x.cond[,variable.name] <- x.cond.scaled
View(x.cond)
object$colnum
center.xval <- x.cond[, object$colnum]
center.xval <- center.xval+matrix(rnorm(200*ncol(center.xval),0,0.01),nrow = 200)
center.x <- object$param$x.scaled[, object$colnum]
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, object$colnum)
predict <- cbind(rep(1, nrow(Btilde.val)), Btilde.val) %*% object$coef
graphics::plot(x.select,predict,type = 'l')
center.xval <- center.xval+matrix(rnorm(200*ncol(center.xval),0,0.001),nrow = 200)
center.x <- object$param$x.scaled[, object$colnum]
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, object$colnum)
predict <- cbind(rep(1, nrow(Btilde.val)), Btilde.val) %*% object$coef
graphics::plot(x.select,predict,type = 'l')
center.xval <- x.cond[, object$colnum]
center.xval <- center.xval#+matrix(rnorm(200*ncol(center.xval),0,0.001),nrow = 200)
center.x <- object$param$x.scaled[, object$colnum]
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, object$colnum)
center.xval <- center.xval+matrix(rnorm(200*ncol(center.xval),0,0.001),nrow = 200)
center.x <- object$param$x.scaled[, object$colnum]
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, object$colnum)
predict <- as.matrix(cbind(rep(1, nrow(Btilde.val)), Btilde.val, x[, !names(x) %in% name.num])) %*% object$coef
graphics::plot(x.select,predict,type = 'l')
x.select
predict
predict <- as.matrix(cbind(rep(1, nrow(Btilde.val)), Btilde.val, x[, !names(x.cond) %in% name.num])) %*% object$coef
graphics::plot(x.select,predict,type = 'l')
predict <- as.matrix(cbind(rep(1, nrow(Btilde.val)), Btilde.val, x.cond[, !names(x.cond) %in% name.num])) %*% object$coef
graphics::plot(x.select,predict,type = 'l')
View(x.cond)
summary(object$x[,1])
summary(object$x[,2])
x_val <- as.data.frame(matrix(0,nrow=200,ncol=2))
x_val[,1] <- seq(-3,3,length.out = 200)
y_pred <- predict(fit,x_val)$pred
#' @return a list of components
#' \itemize{
#'  \item predict - a robust estimation result of CATE.
#'  \item x - matrix of predictors.
#'  \item algorithm - fitting algorithm.
#'  \item model - "rcate.am" object.
#'  \item method - estimation method.
#'  }
#' @rdname predict.rcate.am
#' @export
predict.rcate.am <- function(object, x,...) {
algorithm <- object$algorithm
model <- object$model
name.num <- object$param$name.num
center.x <- object$param$x.num.scaled
center.xval <- NULL
for (i in 1:ncol(center.x)) {
xval1 <- (x[,name.num][,i]-object$param$x.mean[i])/object$param$x.sd[i]
center.xval <- cbind(center.xval,xval1)
}
if (algorithm == "SAM") {
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, seq(1:ncol(center.xval)))
mat.val <- as.matrix(cbind(rep(1, nrow(Btilde.val)), Btilde.val,
x[, !names(x) %in% name.num]))
mat.val <- mat.val+matrix(rnorm(ncol(mat.val)*nrow(mat.val),0,0.001))
predict <- mat.val %*% object$coef
}
return(list(predict = predict, x = x, algorithm = object$algorithm,
model = model, method = object$method))
}
y_pred <- predict.rcate.am(fit,x_val)$pred
object=fit
x=x_val
x_val
algorithm <- object$algorithm
model <- object$model
name.num <- object$param$name.num
center.x <- object$param$x.num.scaled
center.xval <- NULL
for (i in 1:ncol(center.x)) {
xval1 <- (x[,name.num][,i]-object$param$x.mean[i])/object$param$x.sd[i]
center.xval <- cbind(center.xval,xval1)
}
if (algorithm == "SAM") {
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, seq(1:ncol(center.xval)))
mat.val <- as.matrix(cbind(rep(1, nrow(Btilde.val)), Btilde.val,
x[, !names(x) %in% name.num]))
mat.val <- mat.val+matrix(rnorm(ncol(mat.val)*nrow(mat.val),0,0.001))
predict <- mat.val %*% object$coef
}
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, seq(1:ncol(center.xval)))
seq(1:ncol(center.xval))
object$nknots
object$lambda.smooth
center.x
center.xval
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, seq(1:ncol(center.xval)))
n <- 1000; p <- 2; set.seed(2223)
X <- as.data.frame(matrix(runif(n*p,-3,3),nrow=n,ncol=p))
tau = 3*X[,1]-2*X[,2]
p = 1/(1+exp(-X[,1]+X[,2]))
d = rbinom(n,1,p)
t = 2*d-1
y = 100+tau*t/2 + rnorm(n,0,1); set.seed(2223)
x_val = as.data.frame(matrix(rnorm(200*2,0,1),nrow=200,ncol=2))
tau_val = 3*x_val[,1]-2*x_val[,2]
fit <- rcate.am(X,y,d,lambda.smooth = 4, method = 'RL')
y_pred <- predict.rcate.am(fit,x_val)$pred
plot(tau_val,y_pred);abline(0,1)
#' @return a list of components
#' \itemize{
#'  \item predict - a robust estimation result of CATE.
#'  \item x - matrix of predictors.
#'  \item algorithm - fitting algorithm.
#'  \item model - "rcate.am" object.
#'  \item method - estimation method.
#'  }
#' @rdname predict.rcate.am
#' @export
predict.rcate.am <- function(object, x,...) {
algorithm <- object$algorithm
model <- object$model
name.num <- object$param$name.num
center.x <- object$param$x.num.scaled
center.xval <- NULL
for (i in 1:ncol(center.x)) {
xval1 <- (x[,name.num][,i]-object$param$x.mean[i])/object$param$x.sd[i]
center.xval <- cbind(center.xval,xval1)
}
if (algorithm == "SAM") {
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, seq(1:ncol(center.xval)))
mat.val <- as.matrix(cbind(rep(1, nrow(Btilde.val)), Btilde.val,
x[, !names(x) %in% name.num]))
mat.val <- mat.val+matrix(rnorm(ncol(mat.val)*nrow(mat.val),0,0.001),nrow = nrow(mat.val))
predict <- mat.val %*% object$coef
}
return(list(predict = predict, x = x, algorithm = object$algorithm,
model = model, method = object$method))
}
y_pred <- predict.rcate.am(fit,x_val)$pred
plot(tau_val,y_pred);abline(0,1)
x_val <- as.data.frame(matrix(0,nrow=200,ncol=2))
x_val[,1] <- seq(-3,3,length.out = 200)
y_pred <- predict.rcate.am(fit,x_val)$pred
#' @return a list of components
#' \itemize{
#'  \item predict - a robust estimation result of CATE.
#'  \item x - matrix of predictors.
#'  \item algorithm - fitting algorithm.
#'  \item model - "rcate.am" object.
#'  \item method - estimation method.
#'  }
#' @rdname predict.rcate.am
#' @export
predict.rcate.am <- function(object, x,...) {
algorithm <- object$algorithm
model <- object$model
name.num <- object$param$name.num
center.x <- object$param$x.num.scaled
center.xval <- NULL
for (i in 1:ncol(center.x)) {
xval1 <- (x[,name.num][,i]-object$param$x.mean[i])/object$param$x.sd[i]
center.xval <- cbind(center.xval,xval1)
}
center.xval <- center.xval+matrix(rnorm(200*ncol(center.xval),0,0.001),nrow = 200)
if (algorithm == "SAM") {
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, seq(1:ncol(center.xval)))
mat.val <- as.matrix(cbind(rep(1, nrow(Btilde.val)), Btilde.val,
x[, !names(x) %in% name.num]))
predict <- mat.val %*% object$coef
}
return(list(predict = predict, x = x, algorithm = object$algorithm,
model = model, method = object$method))
}
y_pred <- predict.rcate.am(fit,x_val)$pred
plot(x_val[,1],y_pred)
#' Marginal treatment effect plot from machine learning algorithms.
#'
#' \code{marginal.rcate.ml} Returns the variable importance level from "rcate.ml" model.
#'
#' @param object "rcate.ml" object.
#' @param variable.col the column number of interested variable. Default is 1.
#' @param ... other.
#' @rdname marginal.rcate.ml
#' @export
marginal.rcate <- function(object, variable.name=NULL,...){
model <- object$model
algorithm <- object$algorithm
x <- object$x
x.mean <- object$param$x.mean
x.sd <- object$param$x.sd
if (is.null(variable.name)) {
variable.name <- colnames(object$param$x.scaled)[1]
}
x.select <- seq(min(x[,variable.name]),max(x[,variable.name]),length.out = 200)
x.cond.scaled <- (x.select-x.mean[variable.name])/x.sd[variable.name]
x.cond <- data.frame(matrix(0,ncol = ncol(x),nrow = 200))
colnames(x.cond) <- colnames(object$param$x.scaled)
x.cond[,variable.name] <- x.cond.scaled
if (algorithm =='GBM') {
pred <- predict(model,x.cond, ntrees=object$n.trees.gbm)
graphics::plot(x.select,pred,type = 'l',xlab=variable.name)
} else if (algorithm == 'NN') {
pred <- rowMeans(predict(model,as.matrix(x.cond)))
graphics::plot(x.select,pred,type = 'l',xlab=variable.name)
} else if (algorithm == 'SAM') {
center.xval <- x.cond[, object$colnum]
center.xval <- center.xval+matrix(rnorm(200*ncol(center.xval),0,0.001),nrow = 200)
center.x <- object$param$x.scaled[, object$colnum]
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, object$colnum)
predict <- as.matrix(cbind(rep(1, nrow(Btilde.val)),
Btilde.val, x.cond[, !names(x.cond) %in% name.num])) %*% object$coef
graphics::plot(x.select,predict,type = 'l')
}
}
n <- 1000; p <- 2; set.seed(2223)
X <- as.data.frame(matrix(runif(n*p,-3,3),nrow=n,ncol=p))
tau = 3*X[,1]-2*X[,2]
p = 1/(1+exp(-X[,1]+X[,2]))
d = rbinom(n,1,p)
t = 2*d-1
y = 100+tau*t/2 + rnorm(n,0,1); set.seed(2223)
x_val = as.data.frame(matrix(rnorm(200*2,0,1),nrow=200,ncol=2))
tau_val = 3*x_val[,1]-2*x_val[,2]
fit <- rcate.am(X,y,d,lambda.smooth = 4, method = 'RL')
marginal.rcate(fit,'V1')
marginal.rcate(fit,'V2')
# load RCATE package and hypertension data
library(RCATE)
data(hypertension)
dt <- hypertension
# remove incomplete observations
dt <- na.omit(dt)
# define x,y,d
x <- dt[,c("diabetes","ckd","cad","mi","chf","hyperlip","atrfib","stroke","copd","depression",
"black","male","bmicalc","pulse","PDC_avg","approxAge2009")]
cols <- c("diabetes","ckd","cad","mi","chf","hyperlip","atrfib","stroke","copd","depression",
"black","male")
x[cols] <- lapply(x[cols], factor)
d <- dt[,'D']
y <- dt[,'avgsysbp']
# use GBM and MCM-EA to do estimation
fit <- rcate.ml(x=x,y=y,d=d)
# Variable importance level
importance <- importance.rcate.ml(fit)
#'
#' @param object "rcate.ml" object.
#' @param plotit whether plot the importance level.
#' @param ... other.
#' @return a list of components
#' \itemize{
#'  \item importance - vector of variable importance level.
#'  }
#' @rdname importance.rcate.ml
#' @export
importance.rcate.ml <- function(object, plotit=TRUE,...) {
importance <- object$importance
algorithm <- object$algorithm
x <- object$x
col <- ncol(x)
if (plotit==TRUE) {
if (algorithm == "GBM") {
importance <- data.frame(Importance=importance,name=names(importance))
par(mgp=c(5,1,0))
par(mar=c(8,8,4,2)+0.1)
graphics::barplot(importance$Importance,
horiz=TRUE,names.arg = importance$name,
main = 'Variable Importance from GBM',
xlab = 'Importance', ylab= 'Variable', las=2, cex.names=0.8)
} else if (algorithm == "NN") {
importance <- data.frame(importance)
par(mgp=c(5,1,0))
par(mar=c(8,8,4,2)+0.1)
graphics::barplot(importance$Importance,
horiz = TRUE,names.arg = importance$Variable,
main = 'Variable Importance from Neural Network',
xlab = 'Importance', ylab= 'Variable', las=2, cex.names=0.8)
}
}
return(importance)
}
# Variable importance level
importance <- importance.rcate.ml(fit)
# show marginal treatment effect plot
marginal.rcate(fit,'PDC_avg')
y_pred <- predict(fit,x)$predict
hist(y_pred)
devtools::install_github("rhli-Hannah/RCATE")
devtools::document()
devtools::check()
devtools::check()
n <- 1000; p <- 3; set.seed(2223)
X <- as.data.frame(matrix(runif(n*p,-3,3),nrow=n,ncol=p))
tau = 6*sin(2*X[,1])+3*(X[,2]+3)*X[,3]
p = 1/(1+exp(-X[,1]+X[,2]))
d = rbinom(n,1,p)
t = 2*d-1
y = 100+4*X[,1]+X[,2]-3*X[,3]+tau*t/2 + rnorm(n,0,1); set.seed(2223)
x_val = matrix(rnorm(200*3,0,1),nrow=200,ncol=3)
tau_val = 6*sin(2*x_val[,1])+3*(x_val[,2]+3)*x_val[,3]
# Use R-learning method and GBM to estimate CATE
fit <- rcate.ml(X,y,d,method='RL',algorithm='GBM')
y_pred <- predict(fit,x_val)$predict
devtools::check()
#' Marginal treatment effect plot.
#'
#' \code{marginal.rcate} Returns the variable importance level from "rcate.ml" model.
#'
#' @param object "rcate.ml" or "rcate.am" object.
#' @param variable.name the name of interested variable. Default is the name of the
#' first continuous variable.
#' @param ... other.
#' @rdname marginal.rcate
#' @export
marginal.rcate <- function(object, variable.name=NULL,...){
model <- object$model
algorithm <- object$algorithm
x <- object$x
x.mean <- object$param$x.mean
x.sd <- object$param$x.sd
if (is.null(variable.name)) {
variable.name <- colnames(object$param$x.scaled)[1]
}
x.select <- seq(min(x[,variable.name]),max(x[,variable.name]),length.out = 100)
x.cond.scaled <- (x.select-x.mean[variable.name])/x.sd[variable.name]
x.cond <- data.frame(matrix(0,ncol = ncol(x),nrow = 100))
colnames(x.cond) <- colnames(object$param$x.scaled)
x.cond[,variable.name] <- x.cond.scaled
if (algorithm =='GBM') {
pred <- predict(model,x.cond, ntrees=object$n.trees.gbm)
graphics::plot(x.select,pred,type = 'l',xlab=variable.name)
} else if (algorithm == 'NN') {
pred <- rowMeans(predict(model,as.matrix(x.cond)))
graphics::plot(x.select,pred,type = 'l',xlab=variable.name)
} else if (algorithm == 'SAM') {
center.xval <- x.cond[, object$colnum]
center.xval <- center.xval+matrix(stats::rnorm(100*ncol(center.xval),0,0.001),nrow = 100)
center.x <- object$param$x.scaled[, object$colnum]
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, object$colnum)
predict <- as.matrix(cbind(rep(1, nrow(Btilde.val)),
Btilde.val, x.cond[, !names(x.cond) %in% object$param$name.num])) %*% object$coef
graphics::plot(x.select,predict,type = 'l')
}
}
# load RCATE package and hypertension data
#library(RCATE)
data(hypertension)
dt <- hypertension
# remove incomplete observations
dt <- na.omit(dt)
# define x,y,d
x <- dt[,c("diabetes","ckd","cad","mi","chf","hyperlip","atrfib","stroke","copd","depression",
"black","male","bmicalc","pulse","PDC_avg","approxAge2009")]
cols <- c("diabetes","ckd","cad","mi","chf","hyperlip","atrfib","stroke","copd","depression",
"black","male")
x[cols] <- lapply(x[cols], factor)
d <- dt[,'D']
y <- dt[,'avgsysbp']
# use GBM and MCM-EA to do estimation
fit <- rcate.ml(x=x,y=y,d=d)
# Variable importance level
importance <- importance.rcate.ml(fit)
# show marginal treatment effect plot
marginal.rcate(fit,'PDC_avg')
y_pred <- predict(fit,x)$predict
hist(y_pred)
