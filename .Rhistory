interaction.depth.mu = 5, cv.mu = 5, n.trees.gbm = 1000,
interaction.depth.gbm = 2, n.cells.nn = NA, dropout.nn = NA,
epochs.nn = 100) {
options(warn=-1)
# Calculate T=2D-1
t <- 2 * d - 1
# Generate the number of cells used in NN
if (is.na(n.cells.nn)) {
n.cells.nn <- c(ncol(x), ceiling(max(ncol(x) * 0.5,1)))
}
# Generate the dropout rate of NN
if (is.na(dropout.nn)) {
dropout.nn <- c(0.5)
}
x.num <- select_if(x, is.numeric)
x.mean <- apply(x.num, 2, mean)
x.sd <- apply(x.num, 2, sd)
x.num.scaled <- scale(x.num)
name.num <- colnames(x.num)
x.other <- data.frame(x[ , -which(names(x) %in% name.num)])
if (ncol(x.other)==0) {
x.scaled <- x.num.scaled
} else {
x.other <- apply(x.other, 2, function(x) as.numeric(as.character(x)))
x.scaled <- cbind(x.num.scaled,x.other)
}
# Estimate mu0(x), mu1(x) and p(x)
data.p <- data.frame(cbind(d, x.scaled))
#colnames(data.p) <- c("d", paste0("X", 1:ncol(x)))
data.p$d <- as.factor(data.p$d)
gbmGrid.p <- expand.grid(interaction.depth = interaction.depth.p,
n.trees = n.trees.p, shrinkage = shrinkage.p,
n.minobsinnode = n.minobsinnode.p)
gbmFit.p <- caret::train(d ~ ., data = data.p, method = "gbm",
verbose = FALSE,
trControl = caret::trainControl(method = "cv", number = cv.p),
tuneGrid = gbmGrid.p)
pscore.hat <- caret::predict.train(gbmFit.p, newdata = data.p, type = "prob")[, 2]
data00 <- data.frame(cbind(y, x.scaled, d))
colnames(data00)[c(1,ncol(data00))] <- c("y", "d")
data020 <- data00[data00$d == 0, ]
data021 <- data00[data00$d == 1, ]
gbmGrid.mu <- expand.grid(interaction.depth = interaction.depth.mu,
n.trees = n.trees.mu, shrinkage = shrinkage.mu,
n.minobsinnode = n.minobsinnode.mu)
gbmFit.mu <- caret::train(y ~ ., data = data00[, -ncol(data00)],
method = "gbm", verbose = FALSE,
trControl = caret::trainControl(method = "cv",
number = cv.mu), tuneGrid = gbmGrid.mu, metric = "MAE")
gbmFit.mu1 <- caret::train(y ~ ., data = data021[, -ncol(data021)],
method = "gbm", verbose = FALSE,
trControl = caret::trainControl(method = "cv",
number = cv.mu), tuneGrid = gbmGrid.mu, metric = "MAE")
gbmFit.mu0 <- caret::train(y ~ ., data = data020[, -ncol(data020)],
method = "gbm", verbose = FALSE,
trControl = caret::trainControl(method = "cv",
number = cv.mu), tuneGrid = gbmGrid.mu, metric = "MAE")
mu0 <- caret::predict.train(gbmFit.mu0, newdata = data00)
mu1 <- caret::predict.train(gbmFit.mu1, newdata = data00)
mu.ea <- caret::predict.train(gbmFit.mu, newdata = data00)
# Do transformation
if (method == "MCMEA") {
y.tr <- 2 * t * (y - mu.ea)
w.tr <- 1/2 * (t * pscore.hat + (1 - t)/2)
} else if (method == "RL") {
y.tr <- 2 * (y - mu.ea)/(t - 2 * pscore.hat + 1)
w.tr <- abs(t - 2 * pscore.hat + 1)/2
} else if (method == "DR") {
y.tr <- (t - 2 * pscore.hat + 1) * (y)/(2 * pscore.hat * (1 - pscore.hat)) +
(pscore.hat - d)/pscore.hat * mu1 + (pscore.hat - d)/(1 - pscore.hat) * mu0
w.tr <- abs((t - 2 * pscore.hat + 1)/(2 * pscore.hat * (1 - pscore.hat)))
}
# Fit GBM
if (algorithm == "GBM") {
data.gbm <- data.frame(cbind(y.tr, x.scaled))
colnames(data.gbm)[1] <- c("y.tr")
model <- gbm::gbm(y.tr ~ ., data = data.gbm, distribution = "laplace",
weights = w.tr, n.trees = n.trees.gbm,
interaction.depth = interaction.depth.gbm)
df.x <- data.frame(x.scaled)
#colnames(df.x) <- paste0("X", 1:ncol(x))
fitted.values <- gbm::predict.gbm(model, df.x, n.trees = n.trees.gbm)
history <- NULL
importance <- gbm::relative.influence(model,n.trees = n.trees.gbm)
} else if (algorithm == "NN") {
x = as.matrix(x.scaled)
y = as.matrix(y.tr)
# function0 <- paste0("layer_dense(units=", n.cells.nn[1],
#                     ", activation='relu',input_shape=ncol(x)) %>% layer_dropout(",
#                     dropout.nn[1], ") %>%")
# function1 <- paste0("layer_dense(units=", n.cells.nn[2:length(n.cells.nn)],
#                     ", activation='relu') %>% layer_dropout(",
#                     dropout.nn[2:length(dropout.nn)], ") %>%")
# function2 <- paste0("keras_model_sequential() %>% ", function0,
#                     do.call(paste, c(as.list(function1), sep = "")),
#                     "layer_dense(units=1, activation='linear')")
#
# model = eval(parse(text = function2))
#
# model %>% keras::compile(loss = "mae", optimizer = "adam")
#
# model %>% keras::fit(x, y, epochs = epochs.nn, verbose = 0, sample_weight = w.tr)
# fitted.values <- model %>% predict(x)
keras_model_simple_mlp <- function(use_bn = FALSE, use_dp = FALSE,
name = NULL) {
# define and return a custom model
keras::keras_model_custom(name = name, function(self) {
# create layers we'll need for the call (this code executes once)
self$dense1 <- keras::layer_dense(units = n.cells.nn[1], activation = "relu")
self$dense1.1 <- keras::layer_dense(units = n.cells.nn[1], activation = "relu")
self$dense1.5 <- keras::layer_dropout(rate = dropout.nn[1])
self$dense2 <- keras::layer_dense(units = n.cells.nn[2:length(n.cells.nn)], activation = "relu")
#self$dense2.5 <- keras::layer_dropout(rate = dropout.nn[2])
self$dense3 <- keras::layer_dense(units = 1, activation = "linear")
if (use_dp)
self$dp <- keras::layer_dropout(rate = 0.5)
if (use_bn)
self$bn <- keras::layer_batch_normalization(axis = -1)
# implement call (this code executes during training & inference)
function(inputs, mask = NULL) {
x <- self$dense1(inputs)
if (use_dp)
x <- self$dp(x)
if (use_bn)
x <- self$bn(x)
self$dense3(x)
}
})
}
model <- keras_model_simple_mlp()
keras::compile(model, loss = "mae", optimizer = "adam")
history <- keras::fit(model,x, y, epochs = epochs.nn, verbose = 0, sample_weight = w.tr)
fitted.values <- rowMeans(predict(model,x))
pred_wrapper <- function(object, newdata) {
as.vector(predict(object, x = as.matrix(newdata)))
}
p1 <- vip::vip(
object = model,                     # fitted model
method = "permute",                 # permutation-based VI scores
num_features = ncol(x),       # default only plots top 10 features
pred_wrapper = pred_wrapper,            # user-defined prediction function
train = as.data.frame(x) ,    # training data
target = y,                   # response values used for training
metric = "rsquared",                # evaluation metric
# progress = "text"                 # request a text-based progress bar
)
importance <- p1$data
}
result <- list(model = model, method = method, algorithm = algorithm,
fitted.values = fitted.values, x = x, y = y, d = d,
y.tr = y.tr, w.tr = w.tr,
n.trees.gbm = n.trees.gbm, history = history, importance = importance,
param = list(x.scaled=x.scaled, name.num=name.num,
x.mean=x.mean, x.sd=x.sd))
class(result) <- "rcate.ml"
return(result)
}
n <- 1000; p <- 3; set.seed(2223)
X <- as.data.frame(matrix(runif(n*p,-3,3),nrow=n,ncol=p))
tau = 6*sin(2*X[,1])+3*(X[,2]+3)*X[,3]
p = 1/(1+exp(-X[,1]+X[,2]))
d = rbinom(n,1,p)
t = 2*d-1
y = 100+4*X[,1]+X[,2]-3*X[,3]+tau*t/2 + rnorm(n,0,1); set.seed(2223)
x_val = matrix(rnorm(200*3,0,1),nrow=200,ncol=3)
tau_val = 6*sin(2*x_val[,1])+3*(x_val[,2]+3)*x_val[,3]
# Use R-learning method and GBM to estimate CATE
fit <- rcate.ml(X,y,d,method='RL',algorithm='GBM')
library(MASS);library(gbm);library(caret);library(plyr);library(dplyr);library(randomForest);library(rmutil);library(keras);library(tensorflow)
n <- 1000; p <- 3; set.seed(2223)
X <- as.data.frame(matrix(runif(n*p,-3,3),nrow=n,ncol=p))
tau = 6*sin(2*X[,1])+3*(X[,2]+3)*X[,3]
p = 1/(1+exp(-X[,1]+X[,2]))
d = rbinom(n,1,p)
t = 2*d-1
y = 100+4*X[,1]+X[,2]-3*X[,3]+tau*t/2 + rnorm(n,0,1); set.seed(2223)
x_val = matrix(rnorm(200*3,0,1),nrow=200,ncol=3)
tau_val = 6*sin(2*x_val[,1])+3*(x_val[,2]+3)*x_val[,3]
# Use R-learning method and GBM to estimate CATE
fit <- rcate.ml(X,y,d,method='RL',algorithm='GBM')
#'
#' @param object "rcate.ml" object.
#' @param plotit whether plot the importance level.
#' @param ... other.
#' @return a list of components
#' \itemize{
#'  \item importance - vector of variable importance level.
#'  }
#' @rdname importance.rcate.ml
#' @export
importance.rcate.ml <- function(object, plotit=TRUE,...) {
importance <- object$importance
algorithm <- object$algorithm
x <- object$x
col <- ncol(x)
if (plotit==TRUE) {
if (algorithm == "GBM") {
importance <- data.frame(Variable=paste0('X',seq(1:col)),Importance = importance)
graphics::barplot(importance$Importance,
horiz = TRUE,names.arg = importance$Variable,
main = 'Variable Importance from GBM',
xlab = 'Importance', ylab= 'Variable')
} else if (algorithm == "NN") {
importance <- data.frame(importance)
importance[,1] <- stringr::str_replace(importance[,1],'V','X')
graphics::barplot(importance$Importance,
horiz = TRUE,names.arg = importance$Variable,
main = 'Variable Importance from Neural Network',
xlab = 'Importance', ylab= 'Variable')
}
}
return(importance)
}
importance.rcate.ml(fit)
#' Marginal treatment effect plot from machine learning algorithms.
#'
#' \code{marginal.rcate.ml} Returns the variable importance level from "rcate.ml" model.
#'
#' @param object "rcate.ml" object.
#' @param variable.col the column number of interested variable. Default is 1.
#' @param ... other.
#' @rdname marginal.rcate.ml
#' @export
marginal.rcate.ml <- function(object, variable.col=1,...){
model <- object$model
algorithm <- object$algorithm
x <- object$x
x.mean <- object$param$x.mean
x.sd <- object$param$x.sd
x.select <- seq(min(x[,variable.col]),max(x[,variable.col]),length.out = 200)
x.cond.scaled <- (x.select-x.mean[variable.col])/x.sd[variable.col]
x.cond <- matrix(0,ncol = ncol(x),nrow = 200)
x.cond[,variable.col] <- x.cond.scaled
if (algorithm =='GBM') {
x.pred = data.frame(x.cond)
colnames(x.pred) = colnames(x)
pred <- predict(model,x.pred)
graphics::plot(x.select,pred,type = 'l',xlab='x.selected')
} else if (algorithm == 'NN') {
colnames(x.cond) <- colnames(x)
pred <- rowMeans(predict(model,as.matrix(x.cond)))
graphics::plot(x.select,pred,type = 'l',xlab='x.selected')
}
}
marginal.rcate.ml(fit,1)
marginal.rcate.ml(fit,2)
marginal.rcate.ml(fit,3)
importance.rcate.ml(fit)
marginal.rcate.ml(fit,1)
marginal.rcate.ml(fit,3)
x1 <- rnorm(100,0,1)
x2 <- rnorm(100,0,1)
x3 <- x1+x2
x4 <- x1-x2
y <- 3*x1+2*x2+rnorm(100)
lm(y~x1+x2)
fit1 <- lm(y~x1+x2)
summary(fit1)
fit2 <- lm(y~x3+x4)
summary(fit2)
x1 <- rnorm(1000,0,1)
x2 <- rnorm(1000,0,1)
x3 <- x1+x2
x4 <- x1-x2
y <- 3*x1+2*x2+rnorm(1000)
fit1 <- lm(y~x1+x2)
summary(fit1)
fit2 <- lm(y~x3+x4)
summary(fit2)
cor(x3,x4)
cor(x3,x1)
cor(x3,x4)
x1 <- rnorm(1000,0,1)
x2 <- x1/2
x3 <- x1+x2
x4 <- x1-x2
y <- 3*x1+2*x2+rnorm(1000)
fit1 <- lm(y~x1+x2)
summary(fit1)
x1 <- rnorm(1000,0,1)
x2 <- x1/2+rnorm(1000)
x3 <- x1+x2
x4 <- x1-x2
y <- 3*x1+2*x2+rnorm(1000)
fit1 <- lm(y~x1+x2)
summary(fit1)
fit2 <- lm(y~x3+x4)
summary(fit2)
x1 <- rnorm(1000,0,1)
x2 <- x1/2+rnorm(1000,0,0.5)
x3 <- x1+x2
x4 <- x1-x2
y <- 3*x1+2*x2+rnorm(1000)
fit1 <- lm(y~x1+x2)
summary(fit1)
fit2 <- lm(y~x3+x4)
summary(fit2)
x1 <- rnorm(1000,0,1)
x2 <- rnorm(1000,0,1)
x3 <- x1+x2
x4 <- x1-x2
y <- 3*x1+2*x2+rnorm(1000)
fit1 <- lm(y~x1+x2)
summary(fit1)
x1 <- rnorm(1000,0,1)
x2 <- x1/2+rnorm(1000,0,0.5)
x3 <- x1+x2
x4 <- x1-x2
y <- 3*x1+2*x2+rnorm(1000)
fit1 <- lm(y~x1+x2)
summary(fit1)
suppressMessages({
library(magrittr)
library(mgcv)
library(plotly)
library(nlme)
library(gdata)
library(gridExtra)
library(ggpubr)
})
## global option to avoid factor automatically
options(stringsAsFactors = FALSE)
####Gam Model
EH_COVID <- read.csv('C:/Users/rhli/OneDrive/research/2020SPRING/Ezkenazi/data/data/EH_COVID.csv')
in_house_COVID <- read.csv('C:/Users/rhli/OneDrive/research/2020SPRING/Ezkenazi/data/data/in_house_COVID.csv')
vent_COVID <- read.csv('C:/Users/rhli/OneDrive/research/2020SPRING/Ezkenazi/data/data/vent_COVID.csv')
vent_total <- read.csv('C:/Users/rhli/OneDrive/research/2020SPRING/Ezkenazi/data/data/vent_total.csv')
EH_COVID <- EH_COVID[-1]
in_house_COVID <- in_house_COVID[-1]
vent_COVID <- vent_COVID[-1]
vent_total <- vent_total[-1]
EH_COVID$Date <- as.Date(rev(EH_COVID$Date),"%m/%d/%y")
EH_COVID$EH_COVID_cases <- as.numeric(gsub(",", "", rev(EH_COVID$EH_COVID_cases)))
EH_COVID <- subset(EH_COVID, ! is.na(Date) & Date >= as.Date('2020-03-14'))
EH_COVID$numericdate <- as.numeric(EH_COVID$Date)- min(as.numeric(EH_COVID$Date))+1
## Log Transfermation Using EH_COVID dataset
EH_COVID$EH_COVID_cases<- log(EH_COVID$EH_COVID_cases)
EH_COVIDsub <- tail(EH_COVID, 30)
#EH_COVIDsub <- subset(EH_COVID, ! is.na(Date) & Date > as.Date('2020-07-17'))
gam_y <- gam(EH_COVID_cases ~ s(numericdate, k = 10), data = EH_COVIDsub)
x_new <- seq(max(EH_COVID$numericdate)+1, max(EH_COVID$numericdate)+3)
y_pred <- predict(gam_y, data.frame(numericdate = x_new), se.fit = TRUE)
predate <- as.Date(seq(as.numeric(max(EH_COVID$Date))+1,
as.numeric(max(EH_COVID$Date) +3))
,origin = '1970-01-01')
EH_upper <- y_pred$fit + 1.96 * y_pred$se.fit
EH_lower <- y_pred$fit - 1.96 * y_pred$se.fit
## log upper lower bound.
EH_upper <- exp(EH_upper)
EH_lower <- exp(EH_lower)
EH_COVIDpre <- data.frame(Date = predate, EH_COVID_cases = exp(y_pred$fit),
numericdate = seq(max(EH_COVID$numericdate)+1,
max(EH_COVID$numericdate)+3),
EH_lower, EH_upper)
EH_COVID$EH_COVID_cases <- exp(EH_COVID$EH_COVID_cases)
EH_COVIDpre$CI <- paste0(round(EH_COVIDpre$EH_COVID_cases,0),'\n(',round(EH_COVIDpre$EH_lower,0),', ',round(EH_COVIDpre$EH_upper,0),')')
## prediction for In house COVID19
in_house_COVID$date <- as.Date(rev(in_house_COVID$date),"%m/%d/%y")
in_house_COVID$in_house <- rev(in_house_COVID$in_house)
in_house_COVID <- subset(in_house_COVID, ! is.na(date) & date >= as.Date('2020-03-14'))
in_house_COVID$numericdate <- as.numeric(in_house_COVID$date)-
min(as.numeric(in_house_COVID$date))+1
## Log Transfermation
in_house_COVID$in_house <- log(in_house_COVID$in_house)
in_house_COVIDsub <- tail(in_house_COVID, 30)
#in_house_COVIDsub <- subset(in_house_COVID, ! is.na(date) & date > as.Date('2020-07-17'))
gam_y <- gam(in_house ~ s(numericdate, k = 8), data = in_house_COVIDsub)
#gam_y <- gam(in_house ~ s(numericdate,k = 11), data = in_house_COVID)
x_new <- seq(max(in_house_COVID$numericdate)+1, max(in_house_COVID$numericdate)+3)
y_pred <- predict(gam_y, data.frame(numericdate = x_new), se.fit = TRUE)
predate <- as.Date(seq(as.numeric(max(in_house_COVID$date))+1,
as.numeric(max(in_house_COVID$date) +3))
,origin = '1970-01-01')
in_upper <- y_pred$fit + 1.96 * y_pred$se.fit
in_lower <- y_pred$fit - 1.96 * y_pred$se.fit
## log upper lower bound.
in_upper <- exp(in_upper)
in_lower <- exp(in_lower)
in_house_COVIDpre <- data.frame(date = predate, in_house = exp(y_pred$fit),
numericdate = seq(max(in_house_COVID$numericdate)+1,
max(in_house_COVID$numericdate)+3),
in_lower, in_upper)
in_house_COVID$in_house <- exp(in_house_COVID$in_house)
in_house_COVIDpre$CI <- paste0(round(in_house_COVIDpre$in_house,0),'\n(',
round(in_house_COVIDpre$in_lower,0),', ',
round(in_house_COVIDpre$in_upper,0),')')
##############################################################
## prediction for Vent COVID+.
vent_COVID$date <- as.Date(rev(vent_COVID$date),"%m/%d/%y")
vent_COVID$vented_patient <- rev(vent_COVID$vented_patient)
vent_COVID <- subset(vent_COVID, !is.na(date) & date >= '2020-03-14')
vent_COVID$numericdate <- as.numeric(vent_COVID$date)- min(as.numeric(vent_COVID$date))+1
## Log Transfermation
vent_COVID$vented_patient <- log(vent_COVID$vented_patient)
vent_COVIDsub <- tail(vent_COVID, 30)
#vent_COVIDsub <- subset(vent_COVID, !is.na(date) & date > '2020-07-17')
gam_y <- gam(vented_patient ~ s(numericdate, k = 8), data = vent_COVIDsub)
x_new <- seq(max(vent_COVID$numericdate)+1, max(vent_COVID$numericdate)+3)
y_pred <- predict(gam_y, data.frame(numericdate = x_new), se.fit = TRUE)
predate <- as.Date(seq(as.numeric(max(vent_COVID$date))+1,
as.numeric(max(vent_COVID$date) +3))
,origin = '1970-01-01')
vent_COVID_upper <- y_pred$fit + 1.96 * y_pred$se.fit
vent_COVID_lower <- y_pred$fit - 1.96 * y_pred$se.fit
## log upper lower bound.
vent_COVID_upper <- exp(vent_COVID_upper)
vent_COVID_lower <- exp(vent_COVID_lower)
vent_COVID_preset <- data.frame(date = predate, vented_patient = exp(y_pred$fit),
numericdate = seq(max(vent_COVID$numericdate)+1,
max(vent_COVID$numericdate)+3),
vent_COVID_lower, vent_COVID_upper)
vent_COVID$vented_patient <- exp(vent_COVID$vented_patient)
vent_COVID_preset$CI <- paste0(round(vent_COVID_preset$vented_patient,0),'\n(',
round(vent_COVID_preset$vent_COVID_lower,0),', ',
round(vent_COVID_preset$vent_COVID_upper,0),')')
## prediction for Total Vent.
vent_total$date <- as.Date(rev(vent_total$date),"%m/%d/%y")
vent_total$vented_patient <- rev(vent_total$vented_patient)
vent_total <- subset(vent_total, !is.na(date) & date >= '2020-03-14')
vent_total$numericdate <- as.numeric(vent_total$date)- min(as.numeric(vent_total$date))+1
## Log Transfermation
vent_total$vented_patient <- log(vent_total$vented_patient)
# vent_choose <- subset(vent_total, date >  max(vent_total$date) - 15)
vent_choose <- tail(vent_total, 30)
#vent_choose <- subset(vent_total, !is.na(date) & date > '2020-07-17')
gam_y <- gam(vented_patient ~ s(numericdate, k = 8), data = vent_choose)
x_new <- seq(max(vent_total$numericdate)+1, max(vent_total$numericdate)+3)
y_pred <- predict(gam_y, data.frame(numericdate = x_new), se.fit = TRUE)
predate <- as.Date(seq(as.numeric(max(vent_total$date))+1,
as.numeric(max(vent_total$date) +3))
,origin = '1970-01-01')
vent_total_upper <- y_pred$fit + 1.96 * y_pred$se.fit
vent_total_lower <- y_pred$fit - 1.96 * y_pred$se.fit
## log upper lower bound.
vent_total_upper <- exp(vent_total_upper)
vent_total_lower <- exp(vent_total_lower)
vent_total_preset <- data.frame(date = predate, vented_patient = exp(y_pred$fit),
numericdate = seq(max(vent_total$numericdate)+1,
max(vent_total$numericdate)+3),
vent_total_lower, vent_total_upper)
vent_total$vented_patient <- exp(vent_total$vented_patient)
vent_total_preset$CI <- paste0(round(vent_total_preset$vented_patient,0),'\n(',
round(vent_total_preset$vent_total_lower,0),', ',
round(vent_total_preset$vent_total_upper,0),')')
## Combine data frames
EH_COVID$group <- 'EH_COVID'
colnames(EH_COVID) <- c('Date','Counts','numericdate','group')
in_house_COVID$group  <- 'in_house_COVID'
colnames(in_house_COVID) <- c('Date','Counts','numericdate','group')
dt0 <- rbind(EH_COVID)
dt1 <- rbind(in_house_COVID)
EH_COVIDpre$group <- 'EH_COVID'
in_house_COVIDpre$group  <- 'in_house_COVID'
colnames(EH_COVIDpre) <- c('Date','Counts','numericdate','lower','upper','CI','group')
colnames(in_house_COVIDpre) <- c('Date','Counts','numericdate','lower','upper','CI','group')
dt20 <- rbind(EH_COVIDpre)
dt2 <- rbind(in_house_COVIDpre)
vent_COVID$group <- 'vent_COVID'
colnames(vent_COVID) <- c('Date','Counts','numericdate','group')
vent_total$group <- 'vent_total'
colnames(vent_total) <- c('Date','Counts','numericdate','group')
#dt3 <- rbind(vent_COVID,vent_pending,vent_total)
dt3 <- rbind(vent_COVID, vent_total)
vent_COVID_preset$group <- 'vent_COVID'
vent_total_preset$group <- 'vent_total'
colnames(vent_COVID_preset) <- c('Date','Counts','numericdate','lower','upper','CI','group')
colnames(vent_total_preset) <- c('Date','Counts','numericdate','lower','upper','CI','group')
#dt4 <- rbind(vent_COVID_preset,vent_pending_preset,vent_total_preset)
dt4 <- rbind(vent_COVID_preset,vent_total_preset)
tail(dt0,7)
tail(dt0,7)$Counts
max(c(tail(dt0,7)$Counts,dt20$Counts))
min(c(tail(dt0,7)$Counts,dt20$Counts))
dt3.week
dt3.week <- dt3 %>%
dplyr::group_by(group) %>%
slice(tail(row_number(), 7))
fig2 <- ggplot(data=dt3,aes(x=Date,y=Counts,color=group,group=group))+
geom_line()+
#geom_point(size=1)+
#geom_text(aes(label = Counts), size = 2.5,vjust = -0.5,check_overlap = TRUE)+
# geom_ribbon(data=dt4,
#         aes(x = Date, ymin=lower,ymax=upper, fill=group), alpha = 0.5, colour = NA,show.legend = FALSE) +
geom_line(data = dt4, aes(x = Date, y = Counts),
linetype = "dashed")+
# geom_point(data = dt4, aes(x = Date, y = Counts),size=1)+
# geom_text(data = dt4, aes(x = Date,
#                 y= Counts,
#                 label = CI), size = 2.5,check_overlap = TRUE)+
scale_color_manual("", values = c("red", "blue"),
breaks=c("vent_COVID",  "vent_total"),
labels=c("EH patients receiving ventilator support and COVID +",
"Total number of EH patients receiving ventilator support"))+
#  labs(
#   title=" ",
#        caption = "1.Values in the parentheses represent 95% prediction interval. Ganeral additive model with time as a nonlinear predictor is used to estimate future number of patients.  \nP-spline is the smoothing basis. Logarithm transformation is done before fitting the model.
# 2.On June 2, 2020, data source was switched from the Command Center reports to Epic Dashboard reports.")+
ylab('Number of Patients')+
theme_bw() +
theme(legend.position="bottom",plot.caption = element_text(hjust = 0, face= "italic"),
axis.text.x = element_text(angle=45, hjust = 1, size= 7),
panel.grid.major = element_line(colour="grey84", size=0.35),panel.grid.minor = element_blank())+
scale_x_date(date_labels = "%b-%d", breaks = get_sunday_seq(dt3$Date),
date_minor_breaks = "1 day")+
guides(color=guide_legend(ncol=1, byrow=TRUE))+
annotate("rect", xmin = tail(dt0,7)$Date[1], xmax = tail(dt0,7)$Date[7]+3,
ymin = min(c(dt3.week$Counts,dt4$Counts)), ymax = max(c(dt3.week$Counts,dt4$Counts)),
alpha = .2)+
geom_vline(xintercept=as.Date(c("2020-03-24","2020-05-15","2020-05-29",'2020-07-09')),
colour = "gray45",width=0.3)+
annotate("text",x=as.Date(c('2020-03-24','2020-05-15',"2020-05-29",'2020-07-09')),
y=30,label=c("Stage 1: March 24\nStatewide stay at home order","Stage 2: May 15",'Stage 3: May 29','Stage 4: July 9\nMandatory face masks'),vjust=1.4,angle=90,size=2, colour = "gray45")
