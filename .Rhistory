mresi[i] <- sum(tempfit$residuals^2)
}
resi.thres = stats::quantile(mresi, 1 - quant)
nsis <- max(min(sum(used.list < resi.thres), floor(n/df0/3)), 2)
SISind <- sort(initRANKorder[1:nsis])
if (!DOISIS)
return(list(initRANKorder = initRANKorder, SISind = SISind, nsis = nsis))
cat("loop ", curloop, "...SISind ", SISind, "\n")
pick.ind = initRANKorder[1:nsis]
return(pick.ind)
}
#' t = 2*d-1
#' y = 100+tau*t/2 + rnorm(n,0,1); set.seed(2223)
#' x_val = matrix(rnorm(200*2,0,1),nrow=200,ncol=2)
#' tau_val = 3*x_val[,1]-x_val[,2]
#'
#' fit <- rcate.am(X,y,d,lambda.smooth = 2, method = 'RL')
#' y_pred <- predict(fit,x_val)$pred
#' plot(tau_val,y_pred);abline(0,1)
#'
#' @export
rcate.am <- function(x, y, d, method = "MCMEA", NIS = TRUE, nknots = NA,
lambda.smooth = 1, nlambda = 30, nfolds = 5, n.trees.p = 40000,
shrinkage.p = 0.005, n.minobsinnode.p = 10,
interaction.depth.p = 1, cv.p = 2, n.trees.mu = c(1:50) * 50,
shrinkage.mu = 0.01,
n.minobsinnode.mu = 5, interaction.depth.mu = 5, cv.mu = 5) {
options(warn=-1)
# Calculate T=2D-1
t <- 2 * d - 1
if (is.vector(x)) {
x <- matrix(x, ncol = 1)
}
# Number of rows and columns of X
row <- nrow(x)
col <- ncol(x)
# Standardize X
mean.x <- apply(x, 2, mean)
sd.x <- apply(x, 2, sd)
center.x <- (x - mean.x)/sd.x
# Calculate number of knots
if (is.na(nknots)) {
nknots <- floor(sqrt(row)/2)
}
# NIS
if (col < floor(row/log(row)) | NIS == FALSE) {
colnum <- 1:col
} else {
colnum_d <- adaptINIS(x, d)
colnum_y1 <- adaptINIS(x[d == 1, ], y[d == 1])
colnum_y0 <- adaptINIS(x[d == 0, ], y[d == 0])
colnum <- sort(unique(union(union(colnum_d, colnum_y0), colnum_y1)))
}
group <- rep(1:length(colnum), each = nknots + 3)
x.tr <- center.x[, colnum]
# If X has only one dimension, transform it into a matrix with one column
if (is.vector(x.tr)) {
x.tr <- matrix(x.tr, ncol = 1)
}
# Estimate mu0(x), mu1(x) and p(x)
data.p <- data.frame(cbind(factor(d), x))
colnames(data.p) <- c("d", paste0("X", 1:ncol(x)))
data.p$d <- as.factor(data.p$d)
gbmGrid.p <- expand.grid(interaction.depth = interaction.depth.p,
n.trees = n.trees.p, shrinkage = shrinkage.p,
n.minobsinnode = n.minobsinnode.p)
gbmFit.p <- caret::train(d ~ ., data = data.p, method = "gbm",
verbose = FALSE, trControl = caret::trainControl(method = "cv", number = cv.p),
tuneGrid = gbmGrid.p)
pscore.hat <- caret::predict.train(gbmFit.p, newdata = data.p, type = "prob")[, 2]
data00 <- data.frame(cbind(y, x, d))
colnames(data00) <- c("y", paste0("X", 1:ncol(x)), "d")
# data020 <- data00[data00$d == 0, ]
# data021 <- data00[data00$d == 1, ]
gbmGrid.mu <- expand.grid(interaction.depth = interaction.depth.mu,
n.trees = n.trees.mu, shrinkage = shrinkage.mu,
n.minobsinnode = n.minobsinnode.mu)
gbmFit.mu <- caret::train(y ~ ., data = data00[, -ncol(data00)],
method = "gbm", verbose = FALSE, trControl = caret::trainControl(method = "cv",
number = cv.mu), tuneGrid = gbmGrid.mu, metric = "MAE")
# gbmFit.mu1 <- caret::train(y ~ ., data = data021[, -ncol(data021)],
#                            method = "gbm", verbose = FALSE, trControl = caret::trainControl(method = "cv",
#                            number = cv.mu), tuneGrid = gbmGrid.mu, metric = "MAE")
# gbmFit.mu0 <- caret::train(y ~ ., data = data020[, -ncol(data020)],
#                            method = "gbm", verbose = FALSE, trControl = caret::trainControl(method = "cv",
#                            number = cv.mu), tuneGrid = gbmGrid.mu, metric = "MAE")
#
# mu0 <- caret::predict.train(gbmFit.mu0, newdata = data00)
# mu1 <- caret::predict.train(gbmFit.mu1, newdata = data00)
mu.ea <- caret::predict.train(gbmFit.mu, newdata = data00)
# Do transformation
if (method == "MCMEA") {
w.tr <- 1/(t * pscore.hat + (1 - t)/2)
y.tr <- (y - mu.ea) * w.tr
wmat.tr <- matrix(0, row, row)
diag(wmat.tr) <- w.tr * t/2
Btilde <- B_R(x.tr, x.tr, lambda.smooth, nknots, colnum)
x.tr1 <- wmat.tr %*% cbind(rep(1, row), Btilde)
} else if (method == "RL") {
w.tr <- 1
y.tr <- (y - mu.ea) * w.tr
wmat.tr <- matrix(0, row, row)
diag(wmat.tr) <- w.tr * (t - 2 * pscore.hat + 1)/2
Btilde <- B_R(x.tr, x.tr, lambda.smooth, nknots, colnum)
x.tr1 <- wmat.tr %*% cbind(rep(1, row), Btilde)
}
# Fit the weighted LAD model with group SCAD
model <- rqPen::cv.rq.group.pen(x = x.tr1, y = y.tr, groups = as.factor(c(max(group)+1, group)),
tau = 0.5, intercept = FALSE, penalty = 'SCAD',
nfolds = nfolds, criteria = "BIC", nlambda = nlambda)
# Get coefficients and fitted value
coef <- coef(model)
fitted.values <- cbind(rep(1, nrow(Btilde)), Btilde) %*% coef
result <- list(model = model, method = method, algorithm = "SAM",
lambda.smooth = lambda.smooth, fitted.values = fitted.values,
x = x, y = y, d = d, mean.x = mean.x, sd.x = sd.x,
y.tr = y.tr, w.tr = w.tr,
coef = coef, colnum = colnum, nknots = nknots)
class(result) <- "rcate.am"
return(result)
}
n <- 1000; p <- 2; set.seed(2223)
X <- matrix(rnorm(n*p,0,1),nrow=n,ncol=p)
tau = 3*X[,1]-X[,2]
p = 1/(1+exp(-X[,1]+X[,2]))
d = rbinom(n,1,p)
t = 2*d-1
y = 100+tau*t/2 + rnorm(n,0,1); set.seed(2223)
x_val = matrix(rnorm(200*2,0,1),nrow=200,ncol=2)
tau_val = 3*x_val[,1]-x_val[,2]
fit <- rcate.am(X,y,d,lambda.smooth = 2, method = 'RL')
object=fit
algorithm <- object$algorithm
model <- object$model
colnum <- object$colnum
x <- object$x
x.colmean <- colMeans(object$x)
x.cond <- matrix(rep(colMeans(object$x), times=200),
nrow = 200,ncol = ncol(object$x), byrow=TRUE)
x.cond[,variable.col] <- seq(min(object$x[,variable.col]),max(object$x[,variable.col]),length.out = 200)
x.select <- seq(min(object$x[,variable.col]),max(object$x[,variable.col]),length.out = 200)
center.x <- apply(x, 2, function(x) (x - object$mean.x)/object$sd.x)
center.xval <- apply(x.cond, 2, function(x) (x - object$mean.x)/object$sd.x)
center.xval <- center.xval[, colnum]
center.x <- center.x[, colnum]
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, colnum)
predict <- cbind(rep(1, nrow(Btilde.val)), Btilde.val) %*% object$coef
plot(x.select,predict,type = 'l')
#' Marginal treatment effect plot from additive model.
#'
#' \code{marginal.rcate.am} Returns the variable importance level from "rcate.am" model.
#'
#' @param object "rcate.am" object.
#' @param variable.col the column number of interested variable. Default is 1.
#' @param ... other.
#' @rdname marginal.rcate.am
#' @export
marginal.rcate.am <- function(object, variable.col=1,...){
algorithm <- object$algorithm
model <- object$model
colnum <- object$colnum
x <- object$x
x.colmean <- colMeans(object$x)
x.cond <- matrix(rep(colMeans(object$x), times=200),
nrow = 200,ncol = ncol(object$x), byrow=TRUE)
x.cond[,variable.col] <- seq(min(object$x[,variable.col]),max(object$x[,variable.col]),length.out = 200)
x.select <- seq(min(object$x[,variable.col]),max(object$x[,variable.col]),length.out = 200)
center.x <- apply(x, 2, function(x) (x - object$mean.x)/object$sd.x)
center.xval <- apply(x.cond, 2, function(x) (x - object$mean.x)/object$sd.x)
if (algorithm == "SAM") {
center.xval <- center.xval[, colnum]
center.x <- center.x[, colnum]
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, colnum)
predict <- cbind(rep(1, nrow(Btilde.val)), Btilde.val) %*% object$coef
}
plot(x.select,predict,type = 'l')
}
n <- 1000; p <- 2; set.seed(2223)
X <- matrix(runif(n*p,-3,3),nrow=n,ncol=p)
tau = 3*X[,1]-X[,2]
p = 1/(1+exp(-X[,1]+X[,2]))
d = rbinom(n,1,p)
t = 2*d-1
y = 100+tau*t/2 + rnorm(n,0,1); set.seed(2223)
x_val = matrix(rnorm(200*2,0,1),nrow=200,ncol=2)
tau_val = 3*x_val[,1]-x_val[,2]
fit <- rcate.am(X,y,d,lambda.smooth = 2, method = 'RL')
y_pred <- predict(fit,x_val)$pred
plot(tau_val,y_pred);abline(0,1)
#' Marginal treatment effect plot from additive model.
#'
#' \code{marginal.rcate.am} Returns the variable importance level from "rcate.am" model.
#'
#' @param object "rcate.am" object.
#' @param variable.col the column number of interested variable. Default is 1.
#' @param ... other.
#' @rdname marginal.rcate.am
#' @export
marginal.rcate.am <- function(object, variable.col=1,...){
algorithm <- object$algorithm
model <- object$model
colnum <- object$colnum
x <- object$x
x.colmean <- colMeans(object$x)
x.cond <- matrix(rep(colMeans(object$x), times=200),
nrow = 200,ncol = ncol(object$x), byrow=TRUE)
x.cond[,variable.col] <- seq(min(object$x[,variable.col]),max(object$x[,variable.col]),length.out = 200)
x.select <- seq(min(object$x[,variable.col]),max(object$x[,variable.col]),length.out = 200)
center.x <- apply(x, 2, function(x) (x - object$mean.x)/object$sd.x)
center.xval <- apply(x.cond, 2, function(x) (x - object$mean.x)/object$sd.x)
if (algorithm == "SAM") {
center.xval <- center.xval[, colnum]
center.x <- center.x[, colnum]
if (is.vector(center.xval) & is.vector(center.x)) {
center.xval <- matrix(center.xval, ncol = 1)
center.x <- matrix(center.x, ncol = 1)
}
Btilde.val <- B_R(center.xval, center.x, object$lambda.smooth, object$nknots, colnum)
predict <- cbind(rep(1, nrow(Btilde.val)), Btilde.val) %*% object$coef
}
plot(x.select,predict,type = 'l')
}
marginal.rcate.am(fit,1)
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
library(dplyr)
library(gbm)
library(caret)
library(rqPen)
library(splines)
library(MASS)
library(oem)
library(tableone)
library(ggplot2)
library(gridExtra)
library(car)
library(plotly)
library(metR)
library(CondIndTests)
library(ggpubr)
Btilde <- function(x,lambda2,knots2){
B <- bs(x, degree=3, knots=knots2,Boundary.knots = c(-4,4))
D <- diff(diag(ncol(B)), differences = 2)
Omega <- crossprod(D)
n <- length(x)
M <- 1 / n * crossprod(B) + lambda2 * Omega
R <- chol(M)
R1 <- solve(R)
Btilde.mat <- B %*% R1
return(Btilde.mat)
}
B_R <- function(x2,x3,lambda2br,knots.op1) {
Btilde0 <- NULL
result <- knot(x3,knots.op1)
for (i in 1:length(colnum)) {
Btilde1 <- Btilde(x2[,i],lambda2br,result[,i])
Btilde0 <- cbind(Btilde0,Btilde1)
}
return(Btilde0)
}
Btilde.l2 <- function(x,knots2){
B <- bs(x, degree=3, knots=knots2,Boundary.knots = c(-4,4))
D <- diff(diag(ncol(B)), differences = 2)
Omega <- crossprod(D)
n <- length(x)
M <- 1 / n * crossprod(B)*0.0000000001 + Omega
R <- chol(M)
R1 <- solve(R)
Btilde.mat <- B %*% R1
return(Btilde.mat)
}
B_R1 <- function(x2,x3,knots.op1) {
Btilde0 <- NULL
result <- knot(x3,knots.op1)
for (i in 1:length(colnum)) {
Btilde1 <- Btilde.l2(x2[,i],result[,i])
Btilde0 <- cbind(Btilde0,Btilde1)
}
return(Btilde0)
}
knot <- function(x,knots.op) {
apply(x, 2, function(y) quantile(y,probs = head(seq(0,1,length.out = as.numeric(knots.op+2)),-1)[-1]))
}
# mybsfull <- function(x2,x3,knots.op0){
#   x0 <- NULL
#   result <- knot(x3,knots.op0)
#   for (i in 1:ncol(x2)) {
#     x1 <- bs(x2[,i],degree=3, knots=result[,i],Boundary.knots = c(-4,4))
#     x0 <- cbind(x0,x1)
#   }
#   x0
# }
#
# # Additive model
# fun.add <- function(indices,X,Y,pen,lambda.sel) {
#   model1 <- oem(X[indices,],Y[indices],family='gaussian',penalty=pen,
#                 groups = group,lambda = lambda.sel,gamma=3.7)
#   return(c(unlist(model1$beta))[1])
# }
#
# fun.add.lad <- function(indices,X,Y,pen,lambda.sel) {
#   model2 <- rq.group.fit(x=X[indices,],y=Y[indices],groups=as.factor(c(0,group)),tau=0.5,
#                          penalty = pen,lambda=lambda.sel,intercept=FALSE)
#   return(coef(model2)[1])
# }
#
# # Linear part
# fun.li <- function(indices,X,Y,pen='scad',lambda.sel) {
#   x.boot <- X[indices,]
#   y.boot <- Y[indices]
#   model1 <- oem(x=x.boot,y=jitter(y.boot),family='gaussian',penalty=pen,
#                 lambda =lambda.sel,gamma=3.7)
#   pred1.1 <- c(unlist(model1$beta))
#   return(pred1.1)
# }
#
# fun.li.lad <- function(indices,X,Y,pen='SCAD',lambda.sel) {
#   model2 <- rq.nc.fit(x=X[indices,],y=Y[indices],tau=0.5,
#                       penalty = pen,lambda=lambda.sel)
#   return(coef(model2))
# }
data1 <- read.csv('/Users/rhli/OneDrive/research/2019FALL/real data/htnoneobsforpaper.csv')
data2 <- data1[data1$combine %in% c(00000001000000000000,10000001000000000000),] #1653 obs
data2$D <- ifelse(data2$combine==00000001000000000000,0,1)
ACEI <- data2[data2$D==0,]
HCTZ.ACEI <- data2[data2$D==1,]
ACEI$PDC_avg <- ACEI$PDC1_ACEI
ACEI$PDC_max <- ACEI$PDC1_ACEI
HCTZ.ACEI$PDC_avg <- (HCTZ.ACEI$PDC1_Diuretic_Thiazide+HCTZ.ACEI$PDC1_ACEI)/2
HCTZ.ACEI$PDC_max <- pmax(HCTZ.ACEI$PDC1_Diuretic_Thiazide,HCTZ.ACEI$PDC1_ACEI,na.rm=TRUE)
data3 <- rbind(ACEI,HCTZ.ACEI)
data4 <- data3[,names(data3) %in% c('Studyid','gender','race2','approxAge2007',
'diabetes','ckd','cad','mi','chf','hyperlip','atrfib','stroke','copd','depression',
'avgsysbp','avgdiasbp','bmicalc','pulse','PDC_avg','D')]
data4$black <- ifelse(data4$race2=='Black',1,0)
data4$male <- ifelse(data4$gender=='M',1,0)
data4$approxAge2009 <- data4$approxAge2007+2
data4 <- data4[,names(data4) %in% c('Studyid','male','black','approxAge2009',
'diabetes','ckd','cad','mi','chf','hyperlip','atrfib','stroke','copd','depression',
'avgsysbp','avgdiasbp','bmicalc','pulse','PDC_avg','D')]
data4[,names(data4) %in% c('diabetes','ckd','cad','mi',
'chf','hyperlip','atrfib',
'stroke','copd','depression')][is.na(data4[,names(data4) %in% c('diabetes','ckd','cad',
'mi','chf','hyperlip',
'atrfib','stroke','copd',
'depression')])] <- 0 #1653 obs
devtools::use_data(data4,hypertension,internal=TRUE)
usethis::use_data(data4,hypertension,internal=TRUE)
View(data4)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
usethis::use_data(hypertension,internal = TRUE)
usethis::use_data(hypertension)
library(readr)
diamonds <- read_csv("data-raw/diamonds.csv", col_types =
list(
cut = col_factor(c("Fair", "Good", "Very Good", "Premium", "Ideal"), TRUE),
color = col_factor(c("D", "E", "F", "G", "H", "I", "J"), TRUE),
clarity = col_factor(c("I1", "SI2", "SI1", "VS2", "VS1", "VVS2", "VVS1", "IF"), TRUE)
)
)
devtools::use_data(diamonds, overwrite = TRUE)
devtools::document()
devtools::document()
devtools::use_data_raw()
usethis::use_data()
usethis::use_data_raw()
usethis::use_data(hypertension, overwrite = TRUE)
library(dplyr)
library(gbm)
library(caret)
library(rqPen)
library(splines)
library(MASS)
library(oem)
library(tableone)
library(ggplot2)
library(gridExtra)
library(car)
library(plotly)
library(metR)
library(CondIndTests)
library(ggpubr)
Btilde <- function(x,lambda2,knots2){
B <- bs(x, degree=3, knots=knots2,Boundary.knots = c(-4,4))
D <- diff(diag(ncol(B)), differences = 2)
Omega <- crossprod(D)
n <- length(x)
M <- 1 / n * crossprod(B) + lambda2 * Omega
R <- chol(M)
R1 <- solve(R)
Btilde.mat <- B %*% R1
return(Btilde.mat)
}
B_R <- function(x2,x3,lambda2br,knots.op1) {
Btilde0 <- NULL
result <- knot(x3,knots.op1)
for (i in 1:length(colnum)) {
Btilde1 <- Btilde(x2[,i],lambda2br,result[,i])
Btilde0 <- cbind(Btilde0,Btilde1)
}
return(Btilde0)
}
Btilde.l2 <- function(x,knots2){
B <- bs(x, degree=3, knots=knots2,Boundary.knots = c(-4,4))
D <- diff(diag(ncol(B)), differences = 2)
Omega <- crossprod(D)
n <- length(x)
M <- 1 / n * crossprod(B)*0.0000000001 + Omega
R <- chol(M)
R1 <- solve(R)
Btilde.mat <- B %*% R1
return(Btilde.mat)
}
B_R1 <- function(x2,x3,knots.op1) {
Btilde0 <- NULL
result <- knot(x3,knots.op1)
for (i in 1:length(colnum)) {
Btilde1 <- Btilde.l2(x2[,i],result[,i])
Btilde0 <- cbind(Btilde0,Btilde1)
}
return(Btilde0)
}
knot <- function(x,knots.op) {
apply(x, 2, function(y) quantile(y,probs = head(seq(0,1,length.out = as.numeric(knots.op+2)),-1)[-1]))
}
# mybsfull <- function(x2,x3,knots.op0){
#   x0 <- NULL
#   result <- knot(x3,knots.op0)
#   for (i in 1:ncol(x2)) {
#     x1 <- bs(x2[,i],degree=3, knots=result[,i],Boundary.knots = c(-4,4))
#     x0 <- cbind(x0,x1)
#   }
#   x0
# }
#
# # Additive model
# fun.add <- function(indices,X,Y,pen,lambda.sel) {
#   model1 <- oem(X[indices,],Y[indices],family='gaussian',penalty=pen,
#                 groups = group,lambda = lambda.sel,gamma=3.7)
#   return(c(unlist(model1$beta))[1])
# }
#
# fun.add.lad <- function(indices,X,Y,pen,lambda.sel) {
#   model2 <- rq.group.fit(x=X[indices,],y=Y[indices],groups=as.factor(c(0,group)),tau=0.5,
#                          penalty = pen,lambda=lambda.sel,intercept=FALSE)
#   return(coef(model2)[1])
# }
#
# # Linear part
# fun.li <- function(indices,X,Y,pen='scad',lambda.sel) {
#   x.boot <- X[indices,]
#   y.boot <- Y[indices]
#   model1 <- oem(x=x.boot,y=jitter(y.boot),family='gaussian',penalty=pen,
#                 lambda =lambda.sel,gamma=3.7)
#   pred1.1 <- c(unlist(model1$beta))
#   return(pred1.1)
# }
#
# fun.li.lad <- function(indices,X,Y,pen='SCAD',lambda.sel) {
#   model2 <- rq.nc.fit(x=X[indices,],y=Y[indices],tau=0.5,
#                       penalty = pen,lambda=lambda.sel)
#   return(coef(model2))
# }
data1 <- read.csv('/Users/rhli/OneDrive/research/2019FALL/real data/htnoneobsforpaper.csv')
data2 <- data1[data1$combine %in% c(00000001000000000000,10000001000000000000),] #1653 obs
data2$D <- ifelse(data2$combine==00000001000000000000,0,1)
ACEI <- data2[data2$D==0,]
HCTZ.ACEI <- data2[data2$D==1,]
ACEI$PDC_avg <- ACEI$PDC1_ACEI
ACEI$PDC_max <- ACEI$PDC1_ACEI
HCTZ.ACEI$PDC_avg <- (HCTZ.ACEI$PDC1_Diuretic_Thiazide+HCTZ.ACEI$PDC1_ACEI)/2
HCTZ.ACEI$PDC_max <- pmax(HCTZ.ACEI$PDC1_Diuretic_Thiazide,HCTZ.ACEI$PDC1_ACEI,na.rm=TRUE)
data3 <- rbind(ACEI,HCTZ.ACEI)
data4 <- data3[,names(data3) %in% c('Studyid','gender','race2','approxAge2007',
'diabetes','ckd','cad','mi','chf','hyperlip','atrfib','stroke','copd','depression',
'avgsysbp','avgdiasbp','bmicalc','pulse','PDC_avg','D')]
data4$black <- ifelse(data4$race2=='Black',1,0)
data4$male <- ifelse(data4$gender=='M',1,0)
data4$approxAge2009 <- data4$approxAge2007+2
data4 <- data4[,names(data4) %in% c('Studyid','male','black','approxAge2009',
'diabetes','ckd','cad','mi','chf','hyperlip','atrfib','stroke','copd','depression',
'avgsysbp','avgdiasbp','bmicalc','pulse','PDC_avg','D')]
data4[,names(data4) %in% c('diabetes','ckd','cad','mi',
'chf','hyperlip','atrfib',
'stroke','copd','depression')][is.na(data4[,names(data4) %in% c('diabetes','ckd','cad',
'mi','chf','hyperlip',
'atrfib','stroke','copd',
'depression')])] <- 0 #1653 obs
hypertension=data4
usethis::use_data(hypertension, overwrite = TRUE)
devtools::document()
rm(list = c("B_R", "knot"));devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
